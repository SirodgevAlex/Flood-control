Привет!

Очевидно, что надо предложить лучшее по времени решение. Для этого я использовал Redis.

Используя своя алго прошлое я сразу понял, что надо использовать скользящее окно на основе list, в котором будем поддерживать запросы (userID и время запроса как пару). Запросы будут отсортированы по времени (считаем. что их так подают в программу), поэтому внтуренней сортировки не будет. Помимо скользящего окна будем иметь мапу в редисе с ключом userId и значением равным количеству записей для данного userID в скользящем окне. Запрос подали - используем метод Check для данного userID, если он вернул true, то используем метод InsertRequest, который записывает запрос в конец скользящего окна, расширяя его тем семым и увеличивает на один значение для данного userID из мапы, если false, то не записываем. То есть все запросы проходят через скользящее окно. Добавление запроса в окно происходит за O(1) в редисе. Обращение по ключю в мапе тоже за O(1), изменение значения аналогично

Дальше есть два варианта удаления этой записи:

1) Можно просто каждую секунду удалять записи, которые были более N секунд назад
2) Сделать отложенное удаление записи. То есть одновременно с созданием сделать отложенный на N секунд запуск этого же запроса.

   Удаление одной записи вне зависимости от случая происходит за O(1). Когда удаляем запись уменьшем на один значение для ключа userID из мапы. 

Сама Check это просто количество значения для ключа userID из мапы. Там мы поддерживаем количетсво записей в окне для данного userID. Если значение > K, то False, иначе True

Итоговая асимптотика O(M) где M - количетсво запросов.

P S в задании было сказано делать fork, но тогда все смогли бы посмотреть мой код. Я посчитал, что это неконкурентно, поэтому сделал clone.

P P S я специально написал код помимо Check, потому что в моем понимании, функция удаления старых запросов и записи новых смежны с Check

P P P S код имеет концептуальный характер. написав main.go можно условно выкатывать этот флуд контроль. А чтобы правильно 	main.go написать, надо еще мониторинг новых запросов писать и т д (в общем, долго и не нужно в рамках тестового задания, как я считаю)
